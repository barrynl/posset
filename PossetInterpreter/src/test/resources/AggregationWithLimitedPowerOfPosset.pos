/* This needs to become a posset program that involves aggregation, but we start with just including the power operator (^). */
/* Note that the SmallerThanOrEqual, Two and True possets limit the powerOfPosset of the PowerDigit PowerPosset. It is unclear how
this should be interpreted, i.e. the semantics is unclear. De we want: 1) every posset coming from PowerDigit, to be combined with 
every one of the possies from the others, or 2) every posset coming from PowerDigit to not be combined with every one of the 
possies from the other, but should these others be 'ignored' as it were, because they live on another level? If we choose 1) the 
implementation is not trivial, because we iterate the powerOf posset to construct the powersets, but for every powerset we need 
to iterate the powerOf posset entirely to generate all possible combinations. Ths dual function of the powerOf posset is quite complex.
For now we choose option 2), but if we come across a use case in the future that requires otherwise, we might reconsider. */  

main
(
	PowerDigit pb.d[A];
	SmallerThanOrEqual s (
		p1[A];
		p2[B];
		p3[C];
	)
	Three f[B];
	True t[C];
)


^PowerDigit (
	Digit d;
)

LimitedDigit (
	Digit d[A];
	SmallerThanOrEqual s (
		p1[A];
		p2[B];
		p3[C];
	)
	Three f[B];
	True t[C];
)

SmallerThanOrEqual
(
	Digit p1
	(
		d1[A];
		d2[B];
	)
	Digit p2
	(
		d1[C];
		d2[D];
	)
	Boolean p3
	(
		first[E];
	)
)
{
	(A,B,C,D,E)
	
	/* 0 < x = y */
	(#1,#1,#1,#1,#1)
	(#1,#1,#1,#2,#1)
	(#1,#1,#1,#3,#1)
	(#1,#1,#1,#4,#1)
	(#1,#1,#1,#5,#1)
	(#1,#1,#2,#1,#1)
	(#1,#1,#2,#2,#1)
	(#1,#1,#2,#3,#1)
	(#1,#1,#2,#4,#1)
	(#1,#1,#2,#5,#1)
	
	/* 1 >= x = y */
	(#1,#2,#1,#1,#2)
	(#1,#2,#1,#2,#1)
	(#1,#2,#1,#3,#1)
	(#1,#2,#1,#4,#1)
	(#1,#2,#1,#5,#1)
	(#1,#2,#2,#1,#1)
	(#1,#2,#2,#2,#1)
	(#1,#2,#2,#3,#1)
	(#1,#2,#2,#4,#1)
	(#1,#2,#2,#5,#1)

	/* 2 >= x = y */
	(#1,#3,#1,#1,#2)
	(#1,#3,#1,#2,#2)
	(#1,#3,#1,#3,#1)
	(#1,#3,#1,#4,#1)
	(#1,#3,#1,#5,#1)
	(#1,#3,#2,#1,#1)
	(#1,#3,#2,#2,#1)
	(#1,#3,#2,#3,#1)
	(#1,#3,#2,#4,#1)
	(#1,#3,#2,#5,#1)
	
	/* 3 >= x = y */
	(#1,#4,#1,#1,#2)
	(#1,#4,#1,#2,#2)
	(#1,#4,#1,#3,#2)
	(#1,#4,#1,#4,#1)
	(#1,#4,#1,#5,#1)
	(#1,#4,#2,#1,#1)
	(#1,#4,#2,#2,#1)
	(#1,#4,#2,#3,#1)
	(#1,#4,#2,#4,#1)
	(#1,#4,#2,#5,#1)

	/* 4 >= x = y */
	(#1,#5,#1,#1,#2)
	(#1,#5,#1,#2,#2)
	(#1,#5,#1,#3,#2)
	(#1,#5,#1,#4,#2)
	(#1,#5,#1,#5,#1)
	(#1,#5,#2,#1,#1)
	(#1,#5,#2,#2,#1)
	(#1,#5,#2,#3,#1)
	(#1,#5,#2,#4,#1)
	(#1,#5,#2,#5,#1)
	
	/* 5 >= x = y */
	(#2,#1,#1,#1,#2)
	(#2,#1,#1,#2,#2)
	(#2,#1,#1,#3,#2)
	(#2,#1,#1,#4,#2)
	(#2,#1,#1,#5,#2)
	(#2,#1,#2,#1,#1)
	(#2,#1,#2,#2,#1)
	(#2,#1,#2,#3,#1)
	(#2,#1,#2,#4,#1)
	(#2,#1,#2,#5,#1)
	
	/* 6 >= x = y */
	(#2,#2,#1,#1,#2)
	(#2,#2,#1,#2,#2)
	(#2,#2,#1,#3,#2)
	(#2,#2,#1,#4,#2)
	(#2,#2,#1,#5,#2)
	(#2,#2,#2,#1,#2)
	(#2,#2,#2,#2,#1)
	(#2,#2,#2,#3,#1)
	(#2,#2,#2,#4,#1)
	(#2,#2,#2,#5,#1)
	
	/* 7 >= x = y */
	(#2,#3,#1,#1,#2)
	(#2,#3,#1,#2,#2)
	(#2,#3,#1,#3,#2)
	(#2,#3,#1,#4,#2)
	(#2,#3,#1,#5,#2)
	(#2,#3,#2,#1,#2)
	(#2,#3,#2,#2,#2)
	(#2,#3,#2,#3,#1)
	(#2,#3,#2,#4,#1)
	(#2,#3,#2,#5,#1)
	
	/* 8 >= x = y */
	(#2,#4,#1,#1,#2)
	(#2,#4,#1,#2,#2)
	(#2,#4,#1,#3,#2)
	(#2,#4,#1,#4,#2)
	(#2,#4,#1,#5,#2)
	(#2,#4,#2,#1,#2)
	(#2,#4,#2,#2,#2)
	(#2,#4,#2,#3,#2)
	(#2,#4,#2,#4,#1)
	(#2,#4,#2,#5,#1)
	
	/* 9 >= x = y */
	(#2,#5,#1,#1,#2)
	(#2,#5,#1,#2,#2)
	(#2,#5,#1,#3,#2)
	(#2,#5,#1,#4,#2)
	(#2,#5,#1,#5,#2)
	(#2,#5,#2,#1,#2)
	(#2,#5,#2,#2,#2)
	(#2,#5,#2,#3,#2)
	(#2,#5,#2,#4,#2)
	(#2,#5,#2,#5,#1)

}


GreaterThanOrEqual
(
	Digit p1
	(
		d1[A];
		d2[B];
	)
	Digit p2
	(
		d1[C];
		d2[D];
	)
	Boolean p3
	(
		first[E];
	)
)
{
	(A,B,C,D,E)
	
	/* 0 >= x = y */
	(#1,#1,#1,#1,#1)
	(#1,#1,#1,#2,#2)
	(#1,#1,#1,#3,#2)
	(#1,#1,#1,#4,#2)
	(#1,#1,#1,#5,#2)
	(#1,#1,#2,#1,#2)
	(#1,#1,#2,#2,#2)
	(#1,#1,#2,#3,#2)
	(#1,#1,#2,#4,#2)
	(#1,#1,#2,#5,#2)
	
	/* 1 >= x = y */
	(#1,#2,#1,#1,#1)
	(#1,#2,#1,#2,#1)
	(#1,#2,#1,#3,#2)
	(#1,#2,#1,#4,#2)
	(#1,#2,#1,#5,#2)
	(#1,#2,#2,#1,#2)
	(#1,#2,#2,#2,#2)
	(#1,#2,#2,#3,#2)
	(#1,#2,#2,#4,#2)
	(#1,#2,#2,#5,#2)

	/* 2 >= x = y */
	(#1,#3,#1,#1,#1)
	(#1,#3,#1,#2,#1)
	(#1,#3,#1,#3,#1)
	(#1,#3,#1,#4,#2)
	(#1,#3,#1,#5,#2)
	(#1,#3,#2,#1,#2)
	(#1,#3,#2,#2,#2)
	(#1,#3,#2,#3,#2)
	(#1,#3,#2,#4,#2)
	(#1,#3,#2,#5,#2)
	
	/* 3 >= x = y */
	(#1,#4,#1,#1,#1)
	(#1,#4,#1,#2,#1)
	(#1,#4,#1,#3,#1)
	(#1,#4,#1,#4,#1)
	(#1,#4,#1,#5,#2)
	(#1,#4,#2,#1,#2)
	(#1,#4,#2,#2,#2)
	(#1,#4,#2,#3,#2)
	(#1,#4,#2,#4,#2)
	(#1,#4,#2,#5,#2)

	/* 4 >= x = y */
	(#1,#5,#1,#1,#1)
	(#1,#5,#1,#2,#1)
	(#1,#5,#1,#3,#1)
	(#1,#5,#1,#4,#1)
	(#1,#5,#1,#5,#1)
	(#1,#5,#2,#1,#2)
	(#1,#5,#2,#2,#2)
	(#1,#5,#2,#3,#2)
	(#1,#5,#2,#4,#2)
	(#1,#5,#2,#5,#2)
	
	/* 5 >= x = y */
	(#2,#1,#1,#1,#1)
	(#2,#1,#1,#2,#1)
	(#2,#1,#1,#3,#1)
	(#2,#1,#1,#4,#1)
	(#2,#1,#1,#5,#1)
	(#2,#1,#2,#1,#1)
	(#2,#1,#2,#2,#2)
	(#2,#1,#2,#3,#2)
	(#2,#1,#2,#4,#2)
	(#2,#1,#2,#5,#2)
	
	/* 6 >= x = y */
	(#2,#2,#1,#1,#1)
	(#2,#2,#1,#2,#1)
	(#2,#2,#1,#3,#1)
	(#2,#2,#1,#4,#1)
	(#2,#2,#1,#5,#1)
	(#2,#2,#2,#1,#1)
	(#2,#2,#2,#2,#1)
	(#2,#2,#2,#3,#2)
	(#2,#2,#2,#4,#2)
	(#2,#2,#2,#5,#2)
	
	/* 7 >= x = y */
	(#2,#3,#1,#1,#1)
	(#2,#3,#1,#2,#1)
	(#2,#3,#1,#3,#1)
	(#2,#3,#1,#4,#1)
	(#2,#3,#1,#5,#1)
	(#2,#3,#2,#1,#1)
	(#2,#3,#2,#2,#1)
	(#2,#3,#2,#3,#1)
	(#2,#3,#2,#4,#2)
	(#2,#3,#2,#5,#2)
	
	/* 8 >= x = y */
	(#2,#4,#1,#1,#1)
	(#2,#4,#1,#2,#1)
	(#2,#4,#1,#3,#1)
	(#2,#4,#1,#4,#1)
	(#2,#4,#1,#5,#1)
	(#2,#4,#2,#1,#1)
	(#2,#4,#2,#2,#1)
	(#2,#4,#2,#3,#1)
	(#2,#4,#2,#4,#1)
	(#2,#4,#2,#5,#2)
	
	/* 9 >= x = y */
	(#2,#5,#1,#1,#1)
	(#2,#5,#1,#2,#1)
	(#2,#5,#1,#3,#1)
	(#2,#5,#1,#4,#1)
	(#2,#5,#1,#5,#1)
	(#2,#5,#2,#1,#1)
	(#2,#5,#2,#2,#1)
	(#2,#5,#2,#3,#1)
	(#2,#5,#2,#4,#1)
	(#2,#5,#2,#5,#1)

}

/*
 * The plus relations for digits. All plus relations on multiple digits should be derivable from this
 * relation.
 */
Plus
(
	Digit p1
	(
		d1[A];
		d2[B];
	)
	Digit p2
	(
		d1[C];
		d2[D];
	)
	Digit p3
	(
		d1[E];
		d2[F];
	)
)
{
	(A,B,C,D,E,F)
	
	/* 0 + x = y */
	(#1,#1,#1,#1,#1,#1)
	(#1,#1,#1,#2,#1,#2)
	(#1,#1,#1,#3,#1,#3)
	(#1,#1,#1,#4,#1,#4)
	(#1,#1,#1,#5,#1,#5)
	(#1,#1,#2,#1,#2,#1)
	(#1,#1,#2,#2,#2,#2)
	(#1,#1,#2,#3,#2,#3)
	(#1,#1,#2,#4,#2,#4)
	(#1,#1,#2,#5,#2,#5)
	
	/* 1 + x = y */
	(#1,#2,#1,#1,#1,#2)
	(#1,#2,#1,#2,#1,#3)
	(#1,#2,#1,#3,#1,#4)
	(#1,#2,#1,#4,#1,#5)
	(#1,#2,#1,#5,#2,#1)
	(#1,#2,#2,#1,#2,#2)
	(#1,#2,#2,#2,#2,#3)
	(#1,#2,#2,#3,#2,#4)
	(#1,#2,#2,#4,#2,#5)
	(#1,#2,#2,#5,#1,#1)
	
	/* 2 + x = y */
	(#1,#3,#1,#1,#1,#3)
	(#1,#3,#1,#2,#1,#4)
	(#1,#3,#1,#3,#1,#5)
	(#1,#3,#1,#4,#2,#1)
	(#1,#3,#1,#5,#2,#2)
	(#1,#3,#2,#1,#2,#3)
	(#1,#3,#2,#2,#2,#4)
	(#1,#3,#2,#3,#2,#5)
	(#1,#3,#2,#4,#1,#1)
	(#1,#3,#2,#5,#1,#2)
	
	/* 3 + x = y */
	(#1,#4,#1,#1,#1,#4)
	(#1,#4,#1,#2,#1,#5)
	(#1,#4,#1,#3,#2,#1)
	(#1,#4,#1,#4,#2,#2)
	(#1,#4,#1,#5,#2,#3)
	(#1,#4,#2,#1,#2,#4)
	(#1,#4,#2,#2,#2,#5)
	(#1,#4,#2,#3,#1,#1)
	(#1,#4,#2,#4,#1,#2)
	(#1,#4,#2,#5,#1,#3)
	
	/* 4 + x = y */
	(#1,#5,#1,#1,#1,#5)
	(#1,#5,#1,#2,#2,#1)
	(#1,#5,#1,#3,#2,#2)
	(#1,#5,#1,#4,#2,#3)
	(#1,#5,#1,#5,#2,#4)
	(#1,#5,#2,#1,#2,#5)
	(#1,#5,#2,#2,#1,#1)
	(#1,#5,#2,#3,#1,#2)
	(#1,#5,#2,#4,#1,#3)
	(#1,#5,#2,#5,#1,#4)
	
	/* 5 + x = y */
	(#2,#1,#1,#1,#2,#1)
	(#2,#1,#1,#2,#2,#2)
	(#2,#1,#1,#3,#2,#3)
	(#2,#1,#1,#4,#2,#4)
	(#2,#1,#1,#5,#2,#5)
	(#2,#1,#2,#1,#1,#1)
	(#2,#1,#2,#2,#1,#2)
	(#2,#1,#2,#3,#1,#3)
	(#2,#1,#2,#4,#1,#4)
	(#2,#1,#2,#5,#1,#5)
	
	/* 6 + x = y */
	(#2,#2,#1,#1,#2,#2)
	(#2,#2,#1,#2,#2,#3)
	(#2,#2,#1,#3,#2,#4)
	(#2,#2,#1,#4,#2,#5)
	(#2,#2,#1,#5,#1,#1)
	(#2,#2,#2,#1,#1,#2)
	(#2,#2,#2,#2,#1,#3)
	(#2,#2,#2,#3,#1,#4)
	(#2,#2,#2,#4,#1,#5)
	(#2,#2,#2,#5,#2,#1)
	
	/* 7 + x = y */
	(#2,#3,#1,#1,#2,#3)
	(#2,#3,#1,#2,#2,#4)
	(#2,#3,#1,#3,#2,#5)
	(#2,#3,#1,#4,#1,#1)
	(#2,#3,#1,#5,#1,#2)
	(#2,#3,#2,#1,#1,#3)
	(#2,#3,#2,#2,#1,#4)
	(#2,#3,#2,#3,#1,#5)
	(#2,#3,#2,#4,#2,#1)
	(#2,#3,#2,#5,#2,#2)
	
	/* 8 + x = y */
	(#2,#4,#1,#1,#2,#4)
	(#2,#4,#1,#2,#2,#5)
	(#2,#4,#1,#3,#1,#1)
	(#2,#4,#1,#4,#1,#2)
	(#2,#4,#1,#5,#1,#3)
	(#2,#4,#2,#1,#1,#4)
	(#2,#4,#2,#2,#1,#5)
	(#2,#4,#2,#3,#2,#1)
	(#2,#4,#2,#4,#2,#2)
	(#2,#4,#2,#5,#2,#3)
	
	/* 9 + x = y */
	(#2,#5,#1,#1,#2,#5)
	(#2,#5,#1,#2,#1,#1)
	(#2,#5,#1,#3,#1,#2)
	(#2,#5,#1,#4,#1,#3)
	(#2,#5,#1,#5,#1,#4)
	(#2,#5,#2,#1,#1,#5)
	(#2,#5,#2,#2,#2,#1)
	(#2,#5,#2,#3,#2,#2)
	(#2,#5,#2,#4,#2,#3)
	(#2,#5,#2,#5,#2,#4)
}

/* define the ten digits as specifics from posset Digit */

Zero(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#1,#1)}
One(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#1,#2)}
Two(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#1,#3)}
Three(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#1,#4)}
Four(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#1,#5)}
Five(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#2,#1)}
Six(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#2,#2)}
Seven(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#2,#3)}
Eight(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#2,#4)}
Nine(Digit o1(d1[Y];d2[Z];)){(Y,Z)(#2,#5)}

/* A digit has 10 possibilities */

Digit
(
	'2 d1;
	'5 d2;
)

Or
(
	Boolean first ( first[A]; )
	Boolean second ( first[B]; )
	Boolean third ( first[C]; )
)
{
	(A,B,C)
	(#1,#1,#1)
	(#1,#2,#1)
	(#2,#1,#1)
	(#2,#2,#2)
}

XOr
(
	Boolean first (first[A];)
	Boolean second (first[B];)
	Boolean third (first[C];)
)
{
	(A,B,C)
	(#1,#1,#2)
	(#1,#2,#1)
	(#2,#1,#1)
	(#2,#2,#2)
}

And
(
	Boolean first (first[A];)
	Boolean second (first[B];)
	Boolean third (first[C];)
)
{
	(A,B,C)
	(#1,#1,#1)
	(#1,#2,#2)
	(#2,#1,#2)
	(#2,#2,#2)
}

True
(
	Boolean first
	(
		first[A];
	)
)
{
	(A)
	(#1)
}

False
(
	Boolean first
	(
		first[A];
	)
)
{
	(A)
	(#2)
}

/* The boolean consists of two possible values. */
Boolean
(
	'2 first;
)